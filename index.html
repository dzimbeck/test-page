<!DOCTYPE html>
<html>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <title>BitBay Solidity</title>
</head>
<body>
<div id="Loaded"></div>
<p id="text1"></p>
<input type="button" value="Login" onclick="login()">
<br><br>
<input type="button" value="Frozen Coins Details" onclick="showFrozen()">
<p id="frozentext"></p>
<br><br>
<input type="button" value="Release Frozen Funds" onclick="sendFrozen()">
<br><br>
<input type="button" value="Show liquid/reserve chart" onclick="showPegChart()">
<input class="textBox" id="range1" type="text" maxlength="30"    required/>
<input class="textBox" id="range2" type="text" maxlength="30"    required/>
<div id="chartContainer" style="height: 150px; width: 50%; border: 5px solid #d9dbda"></div>
<br><br>
<p id="networkinfo"></p>
<br><br>
<p id="BridgeInfo">Bridge Tools:</p><br>
<input type="button" value="Mint/Redeem coins from BitBay" onclick="mintFromBitBay(document.getElementById('jsonproof').value)">
<input class="textBox" id="jsonproof" type="text" width="70"    required/>
<br><br>
<input type="button" value="Register BitBay Address for bridge(burn): " onclick="registerBitBay(document.getElementById('myBAYaddy').value)">
<input class="textBox" id="myBAYaddy" type="text" width="70"    required/>
<br><br>
<input type="button" value="Burn coins back to BitBay: " onclick="burnToBitBay(document.getElementById('myBAYamount').value)">
<input class="textBox" id="myBAYamount" type="text" width="70"    required/>
<select id="amountToBurn">
<option>Reserve Coins</option>
<option>Liquid Coins</option>
</select>
<br>
<p id="merkleintro">Show my receipts/proofs for redeeming on BitBay</p>
<input type="button" value="Show next receipt" onclick="showNonces()">
<input type="button" value="Copy to clipboard" onclick="copyNonce()">
<p id="merkletext"></p>
<br><br>
<img src="./walrus.png" style="height: 75px; width: 75px;"/>
<p id="swapintro">Decentralized exchange through Uniswap, Pancakeswap and more</p>
<br>
<select id="exchangeSelect">
<option>WalrusSwap</option>
</select>
<br>
<input type="button" value="Add Liquidity" onclick="addLiquidity()">

<br>
<select id="Coin1" style="width:150px">
<option>HappyWalrusCoin</option>
<option>Wrapped ETH</option>
</select>
Amount to add: 
<input class="textBox" id="Coin1amount" type="text" width="70"    required/>
Min/Max price fluctuation:
<input class="textBox" id="CoinPercent" type="text" width="70"    required/>%
<br>
<select id="Coin2" style="width:150px">
<option>BitBay Liquid</option>
<option>BitBay Reserve</option>
</select>
Amount to add: 
<input class="textBox" id="Coin2amount" type="text" width="70"    required/>
<p id="additionalCoins">Reserve required for deposit(in addition to liquid coins): </p>
<br>
<p id="addliquidtext"></p>

<script src="web3.min.js"></script>
<script src="merkletree.js"></script>
<script type="text/javascript" src="./BAYL.js"></script>
<script type="text/javascript" src="./BAYR.js"></script>
<script type="text/javascript" src="./BAYF.js"></script>
<script type="text/javascript" src="./BAYData.js"></script>
<script type="text/javascript" src="./BAYAdmin.js"></script>
<link rel="stylesheet" type="text/css" href="./chartist.min.css">
<script type="text/javascript" src="./coin.js"></script>
<script type="text/javascript" src="./crypto-sha256.js"></script>
<script type="text/javascript" src="./jsbn.js"></script>
<script type="text/javascript" src="./chartist.js"></script>
<script type="text/javascript" src="chartist-plugin-tooltip.js"></script>
<script type="text/javascript">
var web3 = [];
var contractInst = [];
//web3[0] = new Web3("https://cloudflare-eth.com");
//web3[1] = new Web3("https://bsc-dataseed.binance.org");
var isConnected = false;
window.addEventListener('ethereum#initialized', login, {
    once: true,
});
async function login() {
    if (window.ethereum) { //Note: for mobile this only works if the webpage has <head> tag
        console.log("connecting");
        await window.ethereum.request({method: 'eth_requestAccounts'});
        web3 = new Web3(window.ethereum);
        console.log("success");
        document.getElementById("Loaded").innerHTML = "Welcome to the BitBay bridge";
        isConnected = true;
        document.getElementById("frozentext").innerHTML = '';
        document.getElementById("merkletext").innerHTML = '';
        lastitem = 10000000;
        await checkbalances();
        getNetworkInfo();        
    } else {
        isConnected = false;
        document.getElementById("Loaded").innerHTML = "Please log in with Metamask. If you don't have the extension you can download it for your browser from the official source."
    }
}

myaccounts = [];
baydatacontract = '';
baylcontract = '';
bayrcontract = '';
bayfcontract = '';
bayadmincontract = '';
networkvars = [];
reservetimelock = 2629800;
BAYAdmin = '';
currentChainId = '';
lastitem = 10000000;

async function checkbalances() {
    if (!isConnected) {
        return;
    }
    myaccounts = await web3.eth.getAccounts();
    if (myaccounts.length == 0) {
        document.getElementById("text1").innerHTML = "Please unlock Metamask so it can connect.";
        return;
    }
    currentChainId = await web3.eth.net.getId();
    netname = "unknown";
    if (currentChainId == 5) {
        netname = "Goerli Testnet";
        BAYLaddy = "0xD7567f0841Aae04833C8c004e8685cBF9F1a6b11";
        BAYRaddy = "0xe491CC5b00e24fE53cCA89adaC79f5D7FdA80a82";
        BAYFaddy = "0x3c4Fa78cA311FF83A5EdF60140B0b45e8c39eBf9";
        BAYDataAddy = "0x7Be96cCeeB7D6488d1656DD43631a61e553a43E7";
        BAYAdmin = "0x79448c4fbdb606DbDFEAC4f2804cDcA1c00FC272";
        pegsteps = 30;
        microsteps = 8;
        deflationrate = 99;
        compoundrate = 5;
        reservetimelock = 120; //Testnet is actually 120 seconds but github reads 10 minutes
    }
    if (netname == "unknown") {
        document.getElementById("text1").innerHTML = "Unsupported network";
    }
    myaccounts = myaccounts[0];
    baydatacontract = new web3.eth.Contract(BAYDataAbi, BAYDataAddy)
    baylcontract = new web3.eth.Contract(BAYLabi, BAYLaddy);
    bayrcontract = new web3.eth.Contract(BAYRabi, BAYRaddy);
    bayfcontract = new web3.eth.Contract(BAYFabi, BAYFaddy);
    bayadmincontract = new web3.eth.Contract(BAYAdminAbi, BAYAdmin);
    await baylcontract.methods.balanceOf(myaccounts).call().then(function (liquid) {
        BAYLBal = web3.utils.fromWei(liquid, 'gwei')*10;         
    })
    await bayrcontract.methods.balanceOf(myaccounts).call().then(function (rval) {
        BAYRBal = web3.utils.fromWei(rval, 'gwei')*10;  
    })
    await bayfcontract.methods.balanceOf(myaccounts).call().then(function (val) {
        BAYFBal = web3.utils.fromWei(val, 'gwei')*10;  
    })
    await window.web3.eth.getBalance(myaccounts, function(err, result) {
        if (err) {
            ETHBalance = err;
        } else {
            ETHBalance = window.web3.utils.fromWei(result, "ether");
        document.getElementById("text1").innerHTML = "Current Network: "+ netname + "<br>" + myaccounts + "<br>ETH balance:" + ETHBalance + "<br>BAY Liquid:" + BAYLBal + "<br>BAY Reserve:" + BAYRBal + "<br>BAY Frozen:" + BAYFBal;
        }
    })
    await bayadmincontract.methods.isActive().call().then(function (isActive) { //May also check if automatic unfreeze and special transactions are enabled
        if(isActive > 1) {
            document.getElementById("text1").innerHTML += "<br>NOTICE: Spending is currently disabled as this contract may be under maintenance."
        }
    })
}

async function getNetworkInfo() {
    await baydatacontract.methods.getState().call().then(function (netvars) {
        networkvars = netvars;
    })
    document.getElementById("networkinfo").innerHTML = "Current Total Network Supply: " + calculateSupply(networkvars[0],networkvars[4],networkvars[3]) + "% (" + networkvars[0] + " / " + (networkvars[1] * networkvars[2]) + ")<br>Peg compression(steps, microsteps): " + networkvars[1] + ", "+ networkvars[2] + "<br>Deflation rate and compound rate: (" + networkvars[4] + "% ^ " + (100 - networkvars[3]) + ")<br>Three way factor to BitBay's 1200 possible supplies: (" + networkvars[1] + " * " + networkvars[2] + " * " + (100 - networkvars[3]) + ")<br>Time delay for reserve payments(in seconds): " + reservetimelock;
}

function calculateSupply(supply, defrate, pegrate) {
    perc = 100;
    x = 0;
    while(x < supply) {
        perc = perc * ((deflationrate ** (100 - pegrate)) / (100 **  (100 - pegrate)));
        x += 1;
    }
    return parseFloat(perc).toFixed(8);
}

async function showFrozen() {
    getNetworkInfo();
    result = [];
    result2 = [];
    await baydatacontract.methods.getFrozen(myaccounts).call().then(function (myresult) {
        result = myresult;
    })
    result2 = networkvars;
    timestamps = [];
    amounts = [];
    x = 0;
    text = "";
    while(x < 4) {
        val2 = 0;
        await baydatacontract.methods.FrozenTXDBTimeSpent(myaccounts,x,0).call().then(function (val) {
            val2 = val;
        });
        if(val2 == 1) {
            await baydatacontract.methods.FrozenTXDBTimeSpent(myaccounts,x,1).call().then(function (val) {
                y = 0;
                amt = 0;
                //If you want you can calculate both liquid and reserve for each payment if you follow the release frozen calculation protocol
                while(y < result2[0]) {
                    amt += parseInt(result[x][y]);
                    y += 1;
                }
                text += "Amount: " + amt + "<br>" + "Timestamp to release funds: " + val + "<br>";
            });
        }
        x += 1;
    }
    if(text == "") {
        text = "You currently have no frozen coins."
    }
    document.getElementById("frozentext").innerHTML = text;
}

function sendFrozen() {
    baydatacontract.methods.ReleaseFrozenFunds(myaccounts).send({"from":myaccounts,"gasLimit": 2500000});
}

async function showPegChart() {
    getNetworkInfo();
    result = [];
    result2 = [];
    await baydatacontract.methods.calculateBalance(myaccounts,0).call().then(function (myresult) {
        result = myresult;
    })
    result2 = networkvars;
    x = 0;
    data = [];
    section = Math.floor(result2[0] / result2[2]);
    ak = Math.floor(result2[0] % result2[2]);
    highkey = 0;
    labels = [];
    iters = 0;
    iters2 = 0;
    min = 0;
    max = parseInt(result2[1] * result2[2]);
    if(document.getElementById("range1").value == "") {
        document.getElementById("range1").value = min;
    } else {
        if(parseInt(document.getElementById("range1").value) > 0) {
            min = parseInt(document.getElementById("range1").value);
        }
    }
    if(document.getElementById("range2").value == "") {
        document.getElementById("range2").value = max;

    } else {
        if(parseInt(document.getElementById("range2").value) < max) {
            max = parseInt(document.getElementById("range2").value);
        }
    }
    if (min >= max) {
        return;
    }
    while(x < result2[1]) {        
        y = 0;
        tot=Math.floor(parseInt(result[2][x])/result2[2]);
        tot2=result[2][x];
        while(y < result2[2]) {
            if(x == section) {
                if(y == ak) {
                    highkey = iters2;
                }
                if(iters >= min && iters <= max) {
                    data.push(parseInt(result[2][parseInt(result2[1])+y]));
                    iters2 += 1;
                }
            } else {
                if(y==result2[2]-1) {
                    if(tot2 < 0) {
                        tot2 = 0;                        
                    }
                    if(iters >= min && iters <= max) {
                        data.push(tot2);
                        iters2 += 1;
                    }
                } else {
                    tot2-=tot;
                    if(tot < 0) {
                        tot = 0;                        
                    }
                    if(iters >= min && iters <= max) {
                        data.push(tot);
                        iters2 += 1;
                    }
                }
            }
            iters += 1;
            y += 1;
        }
        if(iters >= min && iters <= max) {
            labels.push(x);
        }
        x += 1;
    }
    paintchart(labels,data,highkey);
}

function paintchart(mylabels, mydata, highkey) {
    chart = new Chartist.Bar('#chartContainer', {
      labels: mylabels,
      series: [
        mydata
      ]
    }, {
      low: 0,
      showArea: true,
      seriesBarDistance: 50,
      axisX: {
        showLabel: false },
      axisY: {
        labelInterpolationFnc: function(value, index) {
          return index % 0 === 0 ? value : null;
        }
      },
      plugins: [
        Chartist.plugins.tooltip()
      ]
    });

    chart.on('draw', function(context) {
        if(context.type === 'bar' && context.index >= highkey) {
            context.element.attr({
              style: 'stroke: hsla(200, 100%, 50%, 0.5);'
            });
            return;

        }
        if(context.type === 'bar' && context.index < highkey) {
            context.element.attr({
              style: 'stroke: hsla(255, 100%, 50%, 0.5);'
            });

        }
    });
}
jsondata={}
async function mintFromBitBay(jsondata) {
    jsondata = JSON.parse(jsondata.toString().replace(/'/g,'"').replace(/\n/g,'').replace(/\r/g,'').trim());
    bayadmincontract.methods.redeemTX(jsondata['root'],jsondata['proof'],jsondata['reserve'],jsondata['txid']).send({"from":myaccounts,"gasLimit": 2500000});
}

async function registerBitBay(addy) {
    if(addy[0] != 'b' && addy[0] != "B") {
        document.getElementById("text1").innerHTML += "<br><br>Invalid BitBay address.";
        return;
    }
    if(coinjs.addressDecode(addy) == false) {
        document.getElementById("text1").innerHTML += "<br><br>Invalid BitBay address.";
        return;
    }
    found = 1;
    await bayadmincontract.methods.BAYaddress(myaccounts).call().then(function (myresult) {
        if(myresult == addy){
            found = 0;
            document.getElementById("text1").innerHTML += "<br><br>A BitBay address is already registered to your address.";
            return;
        }    
    });
    if(found == 0) {
        return;
    }
    bayadmincontract.methods.register(addy).send({"from":myaccounts,"gasLimit": 500000});
}

async function burnToBitBay(amount) {
    if(await web3.eth.net.getId() != currentChainId) {
        document.getElementById("text1").innerHTML += "<br><br>The selected chain was recently changed or you are not logged in, please log in again.";
        return;
    }
    found = 1;
    await bayadmincontract.methods.BAYaddress(myaccounts).call().then(function (myresult) {
        if(!myresult && myresult.length == 0){
            document.getElementById("text1").innerHTML += "<br><br>You need to register your BitBay address before burning.";
            found = 0;
        }
    });
    if(found == 0) {
        return;
    }
    myadmin = "0x79448c4fbdb606DbDFEAC4f2804cDcA1c00FC272";
    //await baydatacontract.methods.minter().call().then(function (admin) {
    //    myadmin = admin;
    //})
    var myvar = document.getElementById("amountToBurn").value;
    amount = web3.utils.toWei(document.getElementById("myBAYamount").value,'gwei')/10;
    if(BAYAdmin != myadmin) {
        document.getElementById("text1").innerHTML += "<br><br>Burn address does not match known admin contract.";
        return;
    }
    if(myvar == "Reserve Coins") {
        bayrcontract.methods.transfer(BAYAdmin, amount).send({"from":myaccounts,"gasLimit": 2500000});
    }
    if(myvar == "Liquid Coins") {
        baylcontract.methods.transfer(BAYAdmin, amount).send({"from":myaccounts,"gasLimit": 2500000});
    }
}

jsonreceipt = {};
async function showNonces() {
    document.getElementById("merkletext").innerHTML = "Loading...";
    getNetworkInfo();
    item = '';
    returnthis = 0;
    await bayadmincontract.methods.listNonces(myaccounts).call().then(function (myresult) {
        if(myresult.length == 0) {
            document.getElementById("merkletext").innerHTML = 'No history of burned funds to BitBay network from this account.';
            returnthis = 1;
            return;
        }
        if(lastitem == 10000000) {
            lastitem = myresult.length - 1;
        } else {
            if(lastitem != 0) {
                lastitem -= 1;
            } else {
                lastitem = myresult.length - 1;
            }
        }
        item = myresult[lastitem];
    });
    if (returnthis == 1) {
        return;
    }
    intervaltime = 0;
    processingTime = 0;

    jsonreceipt = {'nonce':item};
    await bayadmincontract.methods.BAYaddress(myaccounts).call().then(function (myresult) {
        jsonreceipt['address'] = myresult;
    });
    await bayadmincontract.methods.showReserve(myaccounts, item).call().then(function (myresult) {
        jsonreceipt['reserve'] = myresult;
    });
    await bayadmincontract.methods.highkey(item, myaccounts).call().then(function (myresult) {
        jsonreceipt['section'] = myresult;
    });
    await bayadmincontract.methods.intervaltime().call().then(function (myresult) {
        intervaltime = myresult;
    });
    await bayadmincontract.methods.processingTime(item).call().then(function (myresult) {
        processingTime = myresult;
    });
    steps = parseInt(networkvars[1]) + parseInt(networkvars[2]);
    myhash = web3.utils.keccak256(web3.eth.abi.encodeParameters(['string','uint256[' + steps.toString() + ']','uint','uint'],[jsonreceipt['address'],jsonreceipt['reserve'],jsonreceipt['section'],jsonreceipt['nonce']]));
    x = 0;
    amt = 0;
    while(x < steps) {
        amt += parseInt(jsonreceipt['reserve'][x]);
        x += 1;
    }
    amt = web3.utils.fromWei(amt.toString(), 'gwei')*10;
    document.getElementById("merkletext").innerHTML = "Nonce: " + item + "<br>Hash: " + myhash + "<br>Total coins: " + amt; 
    block = await web3.eth.getBlock(await web3.eth.getBlockNumber());
    if ((parseInt(processingTime) + parseInt(intervaltime) + parseInt(intervaltime)) < parseInt(block.timestamp)) {
        document.getElementById("merkletext").innerHTML += "<br>Merkle Proof: Merkle tree ready, you may copy the receipt to the clipboard.";
        leaves = [];
        await bayadmincontract.methods.listHashes(item).call().then(function (myresult) {
            leaves = myresult;
        });
        tree = new MerkleTree(leaves, web3.utils.keccak256, { sort: true });
        root = tree.getRoot().toString('hex');
        leaf = myhash;
        //proof = tree.getProof(leaf);
        //console.log(tree.verify(proof, leaf, root)) // true
        //console.log(tree)
        //console.log(leaves)
        //console.log(tree.toString())
        jsonreceipt['proof'] = tree.getHexProof(leaf);
        jsonreceipt['root'] = tree.getHexRoot();
    } else {
        document.getElementById("merkletext").innerHTML += "<br>Merkle Proof: This tree is not processed yet. Please check again later.";
        jsonreceipt = {}
    }
}

async function copyNonce() {
    if(JSON.stringify(jsonreceipt) == "{}") {
        document.getElementById("merkletext").innerHTML = "Current receipt is empty or not processed yet.";
        return
    } else {
        navigator.clipboard.writeText(JSON.stringify(jsonreceipt));
    }
}

setInterval(checkbalances, 90000);
</script>
</body>
</html>